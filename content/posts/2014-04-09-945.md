---
title: Golang strings 包中的函数和方法
author: lsvking
type: post
date: 2014-04-09T07:25:00+00:00
url: /945
categories:
  - Go
tags:
  - go

---
```go
------------------------------------------------------------
// Count 计算字符串 sep 在 s 中的非重叠个数<br />
// 如果 sep 为空字符串，则返回 s 中的字符(非字节)个数 + 1<br />
// 使用 Rabin-Karp 算法实现<br />
func Count(s, sep string) int
func main() {<br />
	s := "Hello,世界!!!!!"<br />
	n := strings.Count(s, "!")<br />
	fmt.Println(n) // 5<br />
	n = strings.Count(s, "!!")<br />
	fmt.Println(n) // 2<br />
}

------------------------------------------------------------
// Contains 判断字符串 s 中是否包含子串 substr<br />
// 如果 substr 为空，则返回 true<br />
func Contains(s, substr string) bool
func main() {<br />
	s := "Hello,世界!!!!!"<br />
	b := strings.Contains(s, "!!")<br />
	fmt.Println(b) // true<br />
	b = strings.Contains(s, "!?")<br />
	fmt.Println(b) // false<br />
	b = strings.Contains(s, "")<br />
	fmt.Println(b) // true<br />
}
------------------------------------------------------------
// ContainsAny 判断字符串 s 中是否包含 chars 中的任何一个字符<br />
// 如果 chars 为空，则返回 false<br />
func ContainsAny(s, chars string) bool
func main() {<br />
	s := "Hello,世界!"<br />
	b := strings.ContainsAny(s, "abc")<br />
	fmt.Println(b) // false<br />
	b = strings.ContainsAny(s, "def")<br />
	fmt.Println(b) // true<br />
	b = strings.Contains(s, "")<br />
	fmt.Println(b) // true<br />
}
------------------------------------------------------------
// ContainsRune 判断字符串 s 中是否包含字符 r<br />
func ContainsRune(s string, r rune) bool
func main() {<br />
	s := "Hello,世界!"<br />
	b := strings.ContainsRune(s, '\n')<br />
	fmt.Println(b) // false<br />
	b = strings.ContainsRune(s, '界')<br />
	fmt.Println(b) // true<br />
	b = strings.ContainsRune(s, 0)<br />
	fmt.Println(b) // false<br />
}
------------------------------------------------------------
// Index 返回子串 sep 在字符串 s 中第一次出现的位置<br />
// 如果找不到，则返回 -1，如果 sep 为空，则返回 0。<br />
// 使用 Rabin-Karp 算法实现<br />
func Index(s, sep string) int
func main() {<br />
	s := "Hello,世界!"<br />
	i := strings.Index(s, "h")<br />
	fmt.Println(i) // -1<br />
	i = strings.Index(s, "!")<br />
	fmt.Println(i) // 12<br />
	i = strings.Index(s, "")<br />
	fmt.Println(i) // 0<br />
}
------------------------------------------------------------
// LastIndex 返回子串 sep 在字符串 s 中最后一次出现的位置<br />
// 如果找不到，则返回 -1，如果 sep 为空，则返回字符串的长度<br />
// 使用朴素字符串比较算法实现<br />
func LastIndex(s, sep string) int
func main() {<br />
	s := "Hello,世界! Hello!"<br />
	i := strings.LastIndex(s, "h")<br />
	fmt.Println(i) // -1<br />
	i = strings.LastIndex(s, "H")<br />
	fmt.Println(i) // 14<br />
	i = strings.LastIndex(s, "")<br />
	fmt.Println(i) // 20<br />
}
------------------------------------------------------------
// IndexRune 返回字符 r 在字符串 s 中第一次出现的位置<br />
// 如果找不到，则返回 -1<br />
func IndexRune(s string, r rune) int
func main() {<br />
	s := "Hello,世界! Hello!"<br />
	i := strings.IndexRune(s, '\n')<br />
	fmt.Println(i) // -1<br />
	i = strings.IndexRune(s, '界')<br />
	fmt.Println(i) // 9<br />
	i = strings.IndexRune(s, 0)<br />
	fmt.Println(i) // -1<br />
}
------------------------------------------------------------
// IndexAny 返回字符串 chars 中的任何一个字符在字符串 s 中第一次出现的位置<br />
// 如果找不到，则返回 -1，如果 chars 为空，则返回 -1<br />
func IndexAny(s, chars string) int
func main() {<br />
	s := "Hello,世界! Hello!"<br />
	i := strings.IndexAny(s, "abc")<br />
	fmt.Println(i) // -1<br />
	i = strings.IndexAny(s, "def")<br />
	fmt.Println(i) // 1<br />
	i = strings.IndexAny(s, "")<br />
	fmt.Println(i) // -1<br />
}
------------------------------------------------------------
// LastIndexAny 返回字符串 chars 中的任何一个字符在字符串 s 中最后一次出现的位置<br />
// 如果找不到，则返回 -1，如果 chars 为空，也返回 -1<br />
func LastIndexAny(s, chars string) int
func main() {<br />
	s := "Hello,世界! Hello!"<br />
	i := strings.LastIndexAny(s, "abc")<br />
	fmt.Println(i) // -1<br />
	i = strings.LastIndexAny(s, "def")<br />
	fmt.Println(i) // 15<br />
	i = strings.LastIndexAny(s, "")<br />
	fmt.Println(i) // -1<br />
}
------------------------------------------------------------
// SplitN 以 sep 为分隔符，将 s 切分成多个子串，结果中不包含 sep 本身<br />
// 如果 sep 为空，则将 s 切分成 Unicode 字符列表。<br />
// 如果 s 中没有 sep 子串，则将整个 s 作为 []string 的第一个元素返回<br />
// 参数 n 表示最多切分出几个子串，超出的部分将不再切分。<br />
// 如果 n 为 0，则返回 nil，如果 n 小于 0，则不限制切分个数，全部切分<br />
func SplitN(s, sep string, n int) []string
func main() {<br />
	s := "Hello, 世界! Hello!"<br />
	ss := strings.SplitN(s, " ", 2)<br />
	fmt.Printf("%q\n", ss) // ["Hello," "世界! Hello!"]<br />
	ss = strings.SplitN(s, " ", -1)<br />
	fmt.Printf("%q\n", ss) // ["Hello," "世界!" "Hello!"]<br />
	ss = strings.SplitN(s, "", 3)<br />
	fmt.Printf("%q\n", ss) // ["H" "e" "llo, 世界! Hello!"]<br />
}
------------------------------------------------------------
// SplitN 以 sep 为分隔符，将 s 切分成多个子串，结果中包含 sep 本身<br />
// 如果 sep 为空，则将 s 切分成 Unicode 字符列表。<br />
// 如果 s 中没有 sep 子串，则将整个 s 作为 []string 的第一个元素返回<br />
// 参数 n 表示最多切分出几个子串，超出的部分将不再切分。<br />
// 如果 n 为 0，则返回 nil，如果 n 小于 0，则不限制切分个数，全部切分<br />
func SplitAfterN(s, sep string, n int) []string
func main() {<br />
	s := "Hello, 世界! Hello!"<br />
	ss := strings.SplitAfterN(s, " ", 2)<br />
	fmt.Printf("%q\n", ss) // ["Hello, " "世界! Hello!"]<br />
	ss = strings.SplitAfterN(s, " ", -1)<br />
	fmt.Printf("%q\n", ss) // ["Hello, " "世界! " "Hello!"]<br />
	ss = strings.SplitAfterN(s, "", 3)<br />
	fmt.Printf("%q\n", ss) // ["H" "e" "llo, 世界! Hello!"]<br />
}
------------------------------------------------------------
// Split 以 sep 为分隔符，将 s 切分成多个子切片，结果中不包含 sep 本身<br />
// 如果 sep 为空，则将 s 切分成 Unicode 字符列表。<br />
// 如果 s 中没有 sep 子串，则将整个 s 作为 []string 的第一个元素返回<br />
func Split(s, sep string) []string
func main() {<br />
	s := "Hello, 世界! Hello!"<br />
	ss := strings.Split(s, " ")<br />
	fmt.Printf("%q\n", ss) // ["Hello," "世界!" "Hello!"]<br />
	ss = strings.Split(s, ", ")<br />
	fmt.Printf("%q\n", ss) // ["Hello" "世界! Hello!"]<br />
	ss = strings.Split(s, "")<br />
	fmt.Printf("%q\n", ss) // 单个字符列表<br />
}
------------------------------------------------------------
// SplitAfter 以 sep 为分隔符，将 s 切分成多个子切片，结果中包含 sep 本身<br />
// 如果 sep 为空，则将 s 切分成 Unicode 字符列表。<br />
// 如果 s 中没有 sep 子串，则将整个 s 作为 []string 的第一个元素返回<br />
func SplitAfter(s, sep string) []string
func main() {<br />
	s := "Hello, 世界! Hello!"<br />
	ss := strings.SplitAfter(s, " ")<br />
	fmt.Printf("%q\n", ss) // ["Hello, " "世界! " "Hello!"]<br />
	ss = strings.SplitAfter(s, ", ")<br />
	fmt.Printf("%q\n", ss) // ["Hello, " "世界! Hello!"]<br />
	ss = strings.SplitAfter(s, "")<br />
	fmt.Printf("%q\n", ss) // 单个字符列表<br />
}
------------------------------------------------------------
// Fields 以连续的空白字符为分隔符，将 s 切分成多个子串，结果中不包含空白字符本身<br />
// 空白字符有：\t, \n, \v, \f, \r, ' ', U+0085 (NEL), U+00A0 (NBSP)<br />
// 如果 s 中只包含空白字符，则返回一个空列表<br />
func Fields(s string) []string
func main() {<br />
	s := "Hello, 世界! Hello!"<br />
	ss := strings.Fields(s)<br />
	fmt.Printf("%q\n", ss) // ["Hello," "世界!" "Hello!"]<br />
}
------------------------------------------------------------
// FieldsFunc 以一个或多个满足 f(rune) 的字符为分隔符，<br />
// 将 s 切分成多个子串，结果中不包含分隔符本身。<br />
// 如果 s 中没有满足 f(rune) 的字符，则返回一个空列表。<br />
func FieldsFunc(s string, f func(rune) bool) []string
func isSlash(r rune) bool {<br />
	return r == '\\' || r == '/'<br />
}
func main() {<br />
	s := "C:\\Windows\\System32\\FileName"<br />
	ss := strings.FieldsFunc(s, isSlash)<br />
	fmt.Printf("%q\n", ss) // ["C:" "Windows" "System32" "FileName"]<br />
}
------------------------------------------------------------
// Join 将 a 中的子串连接成一个单独的字符串，子串之间用 sep 分隔<br />
func Join(a []string, sep string) string
func main() {<br />
	ss := []string{"Monday", "Tuesday", "Wednesday"}<br />
	s := strings.Join(ss, "|")<br />
	fmt.Printf("%q\n", s) // "Monday|Tuesday|Wednesday"<br />
}
------------------------------------------------------------
// HasPrefix 判断字符串 s 是否以 prefix 开头<br />
func HasPrefix(s, prefix string) bool
func main() {<br />
	s := "Hello 世界!"<br />
	b := strings.HasPrefix(s, "hello")<br />
	fmt.Println(b) // false<br />
	b = strings.HasPrefix(s, "Hello")<br />
	fmt.Println(b) // true<br />
}
------------------------------------------------------------
// HasPrefix 判断字符串 s 是否以 prefix 结尾<br />
func HasSuffix(s, suffix string) bool
func main() {<br />
	s := "Hello 世界!"<br />
	b := strings.HasSuffix(s, "世界")<br />
	fmt.Println(b) // false<br />
	b = strings.HasSuffix(s, "世界!")<br />
	fmt.Println(b) // true<br />
}
------------------------------------------------------------
// Map 将 s 中满足 mapping(rune) 的字符替换为 mapping(rune) 的返回值。<br />
// 如果 mapping(rune) 返回负数，则相应的字符将被删除。<br />
func Map(mapping func(rune) rune, s string) string
func Slash(r rune) rune {<br />
	if r == '\\' {<br />
		return '/'<br />
	}<br />
	return r<br />
}<br />
func main() {<br />
	s := "C:\\Windows\\System32\\FileName"<br />
	ms := strings.Map(Slash, s)<br />
	fmt.Printf("%q\n", ms) // "C:/Windows/System32/FileName"<br />
}
------------------------------------------------------------
// Repeat 将 count 个字符串 s 连接成一个新的字符串<br />
func Repeat(s string, count int) string
func main() {<br />
	s := "Hello!"<br />
	rs := strings.Repeat(s, 3)<br />
	fmt.Printf("%q\n", rs) // "Hello!Hello!Hello!"<br />
}
------------------------------------------------------------
// ToUpper 将 s 中的所有字符修改为其大写格式<br />
// 对于非 ASCII 字符，它的大写格式需要查表转换<br />
func ToUpper(s string) string
// ToLower 将 s 中的所有字符修改为其小写格式<br />
// 对于非 ASCII 字符，它的小写格式需要查表转换<br />
func ToLower(s string) string
// ToTitle 将 s 中的所有字符修改为其 Title 格式<br />
// 大部分字符的 Title 格式就是其 Upper 格式<br />
// 只有少数字符的 Title 格式是特殊字符<br />
// 这里的 ToTitle 主要给 Title 函数调用<br />
func ToTitle(s string) string
func main() {<br />
	s := "heLLo worLd Ａｂｃ"<br />
	us := strings.ToUpper(s)<br />
	ls := strings.ToLower(s)<br />
	ts := strings.ToTitle(s)<br />
	fmt.Printf("%q\n", us) // "HELLO WORLD ＡＢＣ"<br />
	fmt.Printf("%q\n", ls) // "hello world ａｂｃ"<br />
	fmt.Printf("%q\n", ts) // "HELLO WORLD ＡＢＣ"<br />
}
// 获取非 ASCII 字符的 Title 格式列表<br />
func main() {<br />
	for _, cr := range unicode.CaseRanges {<br />
		// u := uint32(cr.Delta[unicode.UpperCase]) // 大写格式<br />
		// l := uint32(cr.Delta[unicode.LowerCase]) // 小写格式<br />
		t := uint32(cr.Delta[unicode.TitleCase]) // Title 格式<br />
		// if t != 0 && t != u {<br />
		if t != 0 {<br />
			for i := cr.Lo; i <= cr.Hi; i++ {<br />
				fmt.Printf("%c -> %c\n", i, i+t)<br />
			}<br />
		}<br />
	}<br />
}
------------------------------------------------------------
// ToUpperSpecial 将 s 中的所有字符修改为其大写格式。<br />
// 优先使用 _case 中的规则进行转换<br />
func ToUpperSpecial(_case unicode.SpecialCase, s string) string
// ToLowerSpecial 将 s 中的所有字符修改为其小写格式。<br />
// 优先使用 _case 中的规则进行转换<br />
func ToLowerSpecial(_case unicode.SpecialCase, s string) string
// ToTitleSpecial 将 s 中的所有字符修改为其 Title 格式。<br />
// 优先使用 _case 中的规则进行转换<br />
func ToTitleSpecial(_case unicode.SpecialCase, s string) string
_case 规则说明，以下列语句为例：<br />
unicode.CaseRange{'A', 'Z', [unicode.MaxCase]rune{3, -3, 0}}<br />
·其中 'A', 'Z' 表示此规则只影响 'A' 到 'Z' 之间的字符。<br />
·其中 [unicode.MaxCase]rune 数组表示：<br />
当使用 ToUpperSpecial 转换时，将字符的 Unicode 编码与第一个元素值（3）相加<br />
当使用 ToLowerSpecial 转换时，将字符的 Unicode 编码与第二个元素值（-3）相加<br />
当使用 ToTitleSpecial 转换时，将字符的 Unicode 编码与第三个元素值（0）相加
func main() {<br />
	// 定义转换规则<br />
	var _MyCase = unicode.SpecialCase{<br />
		// 将半角逗号替换为全角逗号，ToTitle 不处理<br />
		unicode.CaseRange{',', ',',<br />
			[unicode.MaxCase]rune{'，' - ',', '，' - ',', 0}},<br />
		// 将半角句号替换为全角句号，ToTitle 不处理<br />
		unicode.CaseRange{'.', '.',<br />
			[unicode.MaxCase]rune{'。' - '.', '。' - '.', 0}},<br />
		// 将 ABC 分别替换为全角的 ＡＢＣ、ａｂｃ，ToTitle 不处理<br />
		unicode.CaseRange{'A', 'C',<br />
			[unicode.MaxCase]rune{'Ａ' - 'A', 'ａ' - 'A', 0}},<br />
	}<br />
	s := "ABCDEF,abcdef."<br />
	us := strings.ToUpperSpecial(_MyCase, s)<br />
	fmt.Printf("%q\n", us) // "ＡＢＣDEF，ABCDEF。"<br />
	ls := strings.ToLowerSpecial(_MyCase, s)<br />
	fmt.Printf("%q\n", ls) // "ａｂｃdef，abcdef。"<br />
	ts := strings.ToTitleSpecial(_MyCase, s)<br />
	fmt.Printf("%q\n", ts) // "ABCDEF,ABCDEF."<br />
}
------------------------------------------------------------
// Title 将 s 中的所有单词的首字母修改为其 Title 格式<br />
// BUG: Title 规则不能正确处理 Unicode 标点符号<br />
func Title(s string) string
func main() {<br />
	s := "heLLo worLd"<br />
	ts := strings.Title(s)<br />
	fmt.Printf("%q\n", ts) // "HeLLo WorLd"<br />
}
------------------------------------------------------------
// TrimLeftFunc 将删除 s 头部连续的满足 f(rune) 的字符<br />
func TrimLeftFunc(s string, f func(rune) bool) string
func isSlash(r rune) bool {<br />
	return r == '\\' || r == '/'<br />
}
func main() {<br />
	s := "\\\\HostName\\C\\Windows\\"<br />
	ts := strings.TrimLeftFunc(s, isSlash)<br />
	fmt.Printf("%q\n", ts) // "HostName\\C\\Windows\\"<br />
}
------------------------------------------------------------
// TrimRightFunc 将删除 s 尾部连续的满足 f(rune) 的字符<br />
func TrimRightFunc(s string, f func(rune) bool) string
func isSlash(r rune) bool {<br />
	return r == '\\' || r == '/'<br />
}
func main() {<br />
	s := "\\\\HostName\\C\\Windows\\"<br />
	ts := strings.TrimRightFunc(s, isSlash)<br />
	fmt.Printf("%q\n", ts) // "\\\\HostName\\C\\Windows"<br />
}
------------------------------------------------------------
// TrimFunc 将删除 s 首尾连续的满足 f(rune) 的字符<br />
func TrimFunc(s string, f func(rune) bool) string
func isSlash(r rune) bool {<br />
	return r == '\\' || r == '/'<br />
}
func main() {<br />
	s := "\\\\HostName\\C\\Windows\\"<br />
	ts := strings.TrimFunc(s, isSlash)<br />
	fmt.Printf("%q\n", ts) // "HostName\\C\\Windows"<br />
}
------------------------------------------------------------
// 返回 s 中第一个满足 f(rune) 的字符的字节位置。<br />
// 如果没有满足 f(rune) 的字符，则返回 -1<br />
func IndexFunc(s string, f func(rune) bool) int
func isSlash(r rune) bool {<br />
	return r == '\\' || r == '/'<br />
}
func main() {<br />
	s := "C:\\Windows\\System32"<br />
	i := strings.IndexFunc(s, isSlash)<br />
	fmt.Printf("%v\n", i) // 2<br />
}
------------------------------------------------------------
// 返回 s 中最后一个满足 f(rune) 的字符的字节位置。<br />
// 如果没有满足 f(rune) 的字符，则返回 -1<br />
func LastIndexFunc(s string, f func(rune) bool) int
func isSlash(r rune) bool {<br />
	return r == '\\' || r == '/'<br />
}
func main() {<br />
	s := "C:\\Windows\\System32"<br />
	i := strings.LastIndexFunc(s, isSlash)<br />
	fmt.Printf("%v\n", i) // 10<br />
}
------------------------------------------------------------
// Trim 将删除 s 首尾连续的包含在 cutset 中的字符<br />
func Trim(s string, cutset string) string
func main() {<br />
	s := "    Hello 世界!   "<br />
	ts := strings.Trim(s, " Helo!")<br />
	fmt.Printf("%q\n", ts) // "世界"<br />
}
------------------------------------------------------------
// TrimLeft 将删除 s 头部连续的包含在 cutset 中的字符<br />
func TrimLeft(s string, cutset string) string
func main() {<br />
	s := "    Hello 世界!   "<br />
	ts := strings.TrimLeft(s, " Helo")<br />
	fmt.Printf("%q\n", ts) // "世界!   "<br />
}
------------------------------------------------------------
// TrimRight 将删除 s 尾部连续的包含在 cutset 中的字符<br />
func TrimRight(s string, cutset string) string
func main() {<br />
	s := "    Hello 世界!   "<br />
	ts := strings.TrimRight(s, " 世界!")<br />
	fmt.Printf("%q\n", ts) // "    Hello"<br />
}
------------------------------------------------------------
// TrimSpace 将删除 s 首尾连续的的空白字符<br />
func TrimSpace(s string) string
func main() {<br />
	s := "    Hello 世界!   "<br />
	ts := strings.TrimSpace(s)<br />
	fmt.Printf("%q\n", ts) // "Hello 世界!"<br />
}
------------------------------------------------------------
// TrimPrefix 删除 s 头部的 prefix 字符串<br />
// 如果 s 不是以 prefix 开头，则返回原始 s<br />
func TrimPrefix(s, prefix string) string
func main() {<br />
	s := "Hello 世界!"<br />
	ts := strings.TrimPrefix(s, "Hello")<br />
	fmt.Printf("%q\n", ts) // " 世界"<br />
}
------------------------------------------------------------
// TrimSuffix 删除 s 尾部的 suffix 字符串<br />
// 如果 s 不是以 suffix 结尾，则返回原始 s<br />
func TrimSuffix(s, suffix string) string
func main() {<br />
	s := "Hello 世界!!!!!"<br />
	ts := strings.TrimSuffix(s, "!!!!")<br />
	fmt.Printf("%q\n", ts) // " 世界"<br />
}
------------------------------------------------------------
// Replace 返回 s 的副本，并将副本中的 old 字符串替换为 new 字符串<br />
// 替换次数为 n 次，如果 n 为 -1，则全部替换<br />
// 如果 old 为空，则在副本的每个字符之间都插入一个 new<br />
func Replace(s, old, new string, n int) string
func main() {<br />
	s := "Hello 世界！"<br />
	s = strings.Replace(s, " ", ",", -1)<br />
	fmt.Println(s)<br />
	s = strings.Replace(s, "", "|", -1)<br />
	fmt.Println(s)<br />
}
------------------------------------------------------------
// EqualFold 判断 s 和 t 是否相等。忽略大小写，同时它还会对特殊字符进行转换<br />
// 比如将“ϕ”转换为“Φ”、将“Ǆ”转换为“ǅ”等，然后再进行比较<br />
func EqualFold(s, t string) bool
func main() {<br />
	s1 := "Hello 世界! ϕ Ǆ"<br />
	s2 := "hello 世界! Φ ǅ"<br />
	b := strings.EqualFold(s1, s2)<br />
	fmt.Printf("%v\n", b) // true<br />
}
============================================================
// reader.go
------------------------------------------------------------
// Reader 结构通过读取字符串，实现了 io.Reader，io.ReaderAt，<br />
// io.Seeker，io.WriterTo，io.ByteScanner，io.RuneScanner 接口<br />
type Reader struct {<br />
	s        string // 要读取的字符串<br />
	i        int    // 当前读取的索引位置，从 i 处开始读取数据<br />
	prevRune int    // 读取的前一个字符的索引位置，小于 0 表示之前未读取字符<br />
}
// 通过字符串 s 创建 strings.Reader 对象<br />
// 这个函数类似于 bytes.NewBufferString<br />
// 但比 bytes.NewBufferString 更有效率，而且只读<br />
func NewReader(s string) *Reader { return &Reader{s, 0, -1} }
------------------------------------------------------------
// Len 返回 r.i 之后的所有数据的字节长度<br />
func (r *Reader) Len() int
func main() {<br />
	s := "Hello 世界!"<br />
	// 创建 Reader<br />
	r := strings.NewReader(s)<br />
	// 获取字符串的编码长度<br />
	fmt.Println(r.Len()) // 13<br />
}
------------------------------------------------------------
// Read 将 r.i 之后的所有数据写入到 b 中（如果 b 的容量足够大）<br />
// 返回读取的字节数和读取过程中遇到的错误<br />
// 如果无可读数据，则返回 io.EOF<br />
func (r *Reader) Read(b []byte) (n int, err error)
func main() {<br />
	s := "Hello World!"<br />
	// 创建 Reader<br />
	r := strings.NewReader(s)<br />
	// 创建长度为 5 个字节的缓冲区<br />
	b := make([]byte, 5)<br />
	// 循环读取 r 中的字符串<br />
	for n, _ := r.Read(b); n > 0; n, _ = r.Read(b) {<br />
		fmt.Printf("%q, ", b[:n])  // "Hello", " Worl", "d!"<br />
	}<br />
}
------------------------------------------------------------
// ReadAt 将 off 之后的所有数据写入到 b 中（如果 b 的容量足够大）<br />
// 返回读取的字节数和读取过程中遇到的错误<br />
// 如果无可读数据，则返回 io.EOF<br />
// 如果数据被一次性读取完毕，则返回 io.EOF<br />
func (r *Reader) ReadAt(b []byte, off int64) (n int, err error) 
func main() {<br />
	s := "Hello World!"<br />
	// 创建 Reader<br />
	r := strings.NewReader(s)<br />
	// 创建长度为 5 个字节的缓冲区<br />
	b := make([]byte, 5)<br />
	// 读取 r 中指定位置的字符串<br />
	n, _ := r.ReadAt(b, 0)<br />
	fmt.Printf("%q\n", b[:n]) // "Hello"<br />
	// 读取 r 中指定位置的字符串<br />
	n, _ = r.ReadAt(b, 6)<br />
	fmt.Printf("%q\n", b[:n]) // "World"<br />
}
------------------------------------------------------------
// ReadByte 将 r.i 之后的一个字节写入到返回值 b 中<br />
// 返回读取的字节和读取过程中遇到的错误<br />
// 如果无可读数据，则返回 io.EOF<br />
func (r *Reader) ReadByte() (b byte, err error)
func main() {<br />
	s := "Hello World!"<br />
	// 创建 Reader<br />
	r := strings.NewReader(s)<br />
	// 读取 r 中的一个字节<br />
	for i := 0; i < 3; i++ {<br />
		b, _ := r.ReadByte()<br />
		fmt.Printf("%q, ", b) // 'H', 'e', 'l', <br />
	}<br />
}
------------------------------------------------------------
// UnreadByte 撤消前一次的 ReadByte 操作，即 r.i--<br />
func (r *Reader) UnreadByte() error
func main() {<br />
	s := "Hello World!"<br />
	// 创建 Reader<br />
	r := strings.NewReader(s)<br />
	// 读取 r 中的一个字节<br />
	for i := 0; i < 3; i++ {<br />
		b, _ := r.ReadByte()<br />
		fmt.Printf("%q, ", b) // 'H', 'H', 'H',<br />
		r.UnreadByte()        // 撤消前一次的字节读取操作<br />
	}<br />
}
------------------------------------------------------------
// ReadRune 将 r.i 之后的一个字符写入到返回值 ch 中<br />
// ch：  读取的字符<br />
// size：ch 的编码长度<br />
// err： 读取过程中遇到的错误<br />
// 如果无可读数据，则返回 io.EOF<br />
// 如果 r.i 之后不是一个合法的 UTF-8 字符编码，则返回 utf8.RuneError 字符<br />
func (r *Reader) ReadRune() (ch rune, size int, err error) 
func main() {<br />
	s := "你好 世界！"<br />
	// 创建 Reader<br />
	r := strings.NewReader(s)<br />
	// 读取 r 中的一个字符<br />
	for i := 0; i < 5; i++ {<br />
		b, n, _ := r.ReadRune()<br />
		fmt.Printf(`"%c:%v", `, b, n)<br />
		// "你:3", "好:3", " :1", "世:3", "界:3", <br />
	}<br />
}
------------------------------------------------------------
// 撤消前一次的 ReadRune 操作<br />
func (r *Reader) UnreadRune() error
func main() {<br />
	s := "你好 世界！"<br />
	// 创建 Reader<br />
	r := strings.NewReader(s)<br />
	// 读取 r 中的一个字符<br />
	for i := 0; i < 5; i++ {<br />
		b, _, _ := r.ReadRune()<br />
		fmt.Printf("%q, ", b)<br />
		// '你', '你', '你', '你', '你',<br />
		r.UnreadRune() // 撤消前一次的字符读取操作<br />
	}<br />
}
------------------------------------------------------------
// Seek 用来移动 r 中的索引位置<br />
// offset：要移动的偏移量，负数表示反向移动<br />
// whence：从那里开始移动，0：起始位置，1：当前位置，2：结尾位置<br />
// 如果 whence 不是 0、1、2，则返回错误信息<br />
// 如果目标索引位置超出字符串范围，则返回错误信息<br />
// 目标索引位置不能超出 1 << 31，否则返回错误信息<br />
func (r *Reader) Seek(offset int64, whence int) (int64, error)
func main() {<br />
	s := "Hello World!"<br />
	// 创建 Reader<br />
	r := strings.NewReader(s)<br />
	// 创建读取缓冲区<br />
	b := make([]byte, 5)<br />
	// 读取 r 中指定位置的内容<br />
	r.Seek(6, 0) // 移动索引位置到第 7 个字节<br />
	r.Read(b)    // 开始读取<br />
	fmt.Printf("%q\n", b)<br />
	r.Seek(-5, 1) // 将索引位置移回去<br />
	r.Read(b)     // 继续读取<br />
	fmt.Printf("%q\n", b)<br />
}
------------------------------------------------------------
// WriteTo 将 r.i 之后的数据写入接口 w 中<br />
func (r *Reader) WriteTo(w io.Writer) (n int64, err error)
func main() {<br />
	s := "Hello World!"<br />
	// 创建 Reader<br />
	r := strings.NewReader(s)<br />
	// 创建 bytes.Buffer 对象，它实现了 io.Reader 接口<br />
	buf := bytes.NewBuffer(nil)<br />
	// 将 r 中的数据写入 buf 中<br />
	r.WriteTo(buf)<br />
	fmt.Printf("%q\n", buf) // "Hello World!"<br />
}
============================================================
// replace.go
------------------------------------------------------------
// Replacer 根据一个替换列表执行替换操作<br />
type Replacer struct {<br />
	Replace(s string) string<br />
	WriteString(w io.Writer, s string) (n int, err error)<br />
}
------------------------------------------------------------
// NewReplacer 通过“替换列表”创建一个 Replacer 对象。<br />
// 按照“替换列表”中的顺序进行替换，只替换非重叠部分。<br />
// 如果参数的个数不是偶数，则抛出异常。<br />
// 如果在“替换列表”中有相同的“查找项”，则后面重复的“查找项”会被忽略<br />
func NewReplacer(oldnew ...string) *Replacer
------------------------------------------------------------
// Replace 返回对 s 进行“查找和替换”后的结果<br />
// Replace 使用的是 Boyer-Moore 算法，速度很快<br />
func (r *Replacer) Replace(s string) string
func main() {<br />
	srp := strings.NewReplacer("Hello", "你好", "World", "世界", "!", "！")<br />
	s := "Hello World!Hello World!hello world!"<br />
	rst := srp.Replace(s)<br />
	fmt.Print(rst) // 你好 世界！你好 世界！hello world！<br />
}
func main() {<br />
	wl := []string{"Hello", "Hi", "Hello", "你好"}<br />
	srp := strings.NewReplacer(wl...)<br />
	s := "Hello World! Hello World! hello world!"<br />
	rst := srp.Replace(s)<br />
	fmt.Print(rst) // Hi World! Hi World! hello world!<br />
}
------------------------------------------------------------
// WriteString 对 s 进行“查找和替换”，然后将结果写入 w 中<br />
func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)
func main() {<br />
	wl := []string{"Hello", "你好", "World", "世界", "!", "！"}<br />
	srp := strings.NewReplacer(wl...)<br />
	s := "Hello World!Hello World!hello world!"<br />
	srp.WriteString(os.Stdout, s)<br />
	// 你好 世界！你好 世界！hello world！<br />
}<br />
```